/*! \file gc.c
 *
 * \author John Reppy
 *
 * Sample code
 * CMSC 22600
 * Spring 2024
 * University of Chicago
 */

/*
 * COPYRIGHT (c) 2024 John Reppy (https://cs.uchicago.edu/~jhr)
 * All rights reserved.
 */

#include "mini-ml.h"
#include "statepoints.h"
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>

// on Linux, there is an extra "_" prepended to global names
//
#ifdef __linux__
#  define STACK_MAPS    __LLVM_StackMaps
#else
#  define STACK_MAPS    _LLVM_StackMaps
#endif

// uncomment to turn on GC debugging
#define GC_DEBUG

// the stackmap information generated by llc
extern uint8_t STACK_MAPS[];

static statepoint_table_t* StatePoints = 0;
MML_heap_t _mml_heap;

/* given a known object pointer, forward the object and return the new address */
static MML_word_t forward_ptr (MML_word_t r);

//! check if a word is a pointer, and if so call forward_ptr on it
//
static inline MML_word_t check_and_forward (MML_word_t r)
{
    if (((uint64_t)r & TAG_MASK) == 0) {
        return forward_ptr (r);
    }
    else {
        return r;
    }
}

void _mml_invoke_gc (MML_word_t *sp, size_t allocSz, uint32_t numRoots, MML_word_t *roots)
{

  // swap spaces
    {
        MML_semispace_t *tmp = _mml_heap._toSp;
        _mml_heap._toSp = _mml_heap._fromSp;
        _mml_heap._fromSp = tmp;
      // set _usedTop for both semispaces
        _mml_heap._toSp->_usedTop = _mml_heap._toSp->_baseAddr;
        _mml_heap._fromSp->_usedTop = (uint64_t)_mml_heap._allocPtr;
#ifdef GC_DEBUG
      // DEBUGGING
        fprintf(stderr, "\n\n------------- start GC -------------\n");
        fprintf(stderr, "from space = [%#llx .. %#llx)\n",
            _mml_heap._fromSp->_baseAddr, _mml_heap._fromSp->_usedTop);
        fprintf(stderr, "to space   = [%#llx .. %#llx)\n",
            _mml_heap._toSp->_baseAddr, _mml_heap._toSp->_baseAddr + _mml_heap._toSp->_szB);
#endif
    }

    // scan roots
        for (uint32_t i = 0;  i < numRoots;  i++) {
            roots[i] = check_and_forward(roots[i]);
        }

    // scan stack
    {
#ifdef GC_DEBUG
      // DEBUGGING
        fprintf(stderr, "\n------------- scanning stack -------------\n");
#endif
      // find the top of the MiniML stack
        uint64_t stackPtr = (uint64_t)sp;
        while (lookup_return_address(StatePoints, *(uint64_t*)(stackPtr)) == 0) {
            stackPtr += sizeof(uint64_t);
        }

      // now pointing at a MiniML return address.
        frame_info_t* frame;
        while ((frame = lookup_return_address(StatePoints, *(uint64_t*)(stackPtr))) != 0) {
          // step into frame
            stackPtr += sizeof(uint64_t);
#ifdef GC_DEBUG
          // DEBUGGING
            {
                fprintf(stderr, "\t\tstack pointer: 0x%" PRIX64 "\n", stackPtr);
                fprintf(stderr, "\t\treturn address: 0x%" PRIX64 "\n", frame->retAddr);
                fprintf(stderr, "\t\tframe size: %" PRIu64 "\n", frame->frameSize);
                int numSlots = frame->numSlots;
                pointer_slot_t *curSlot = frame->slots;
                fprintf(stderr, "\t\tnum live ptrs: %u\n", numSlots);
                for (int i = 0; i < numSlots; i++, curSlot++) {
                    uint64_t *p = (uint64_t *)(stackPtr + curSlot->offset);
                    fprintf(stderr, "\t\tptr slot #%u @ %p { ", i, p);
                    int32_t kind = curSlot->kind;
                    if (kind < 0) {
                        fprintf(stderr, "kind: base ptr, ");
                    } else {
                        fprintf(stderr, "kind: ptr derived from slot #%d, ", kind);
                    }
                    fprintf(stderr, "frame offset: %d }\n", curSlot->offset);
                }
            }
#endif

          // process pointers
            for (int i = 0; i < frame->numSlots; i++) {
                pointer_slot_t slotInfo = frame->slots[i];
                if (slotInfo.kind >= 0) {
                    assert(false && "unexpected derived pointer\n");
                }
                MML_word_t *slotPtr = (MML_word_t *)(stackPtr + slotInfo.offset);
#ifdef GC_DEBUG
                {
                    MML_word_t w = *slotPtr;
                    MML_word_t newW = forward_ptr(w);
                    *slotPtr = newW;
                    fprintf(stderr, "[%p] forward %p --> %p\n", slotPtr, w, newW);
                }
#else
                *slotPtr = forward_ptr(*slotPtr);
#endif
            }
          // move to next frame
            stackPtr += frame->frameSize;
        }
    }

  // scan to-space
    {
        MML_semispace_t *toSp = _mml_heap._toSp;

        MML_word_t *p = (MML_word_t *)toSp->_baseAddr;
        while (p < (MML_word_t *)toSp->_usedTop) {
            *p = check_and_forward (*p);
            p++;
        }
    }

  // reset allocation and limit pointers
    _mml_heap._allocPtr = (MML_word_t *)(_mml_heap._toSp->_usedTop);
    _mml_heap._limitPtr =
        (MML_word_t *)(_mml_heap._toSp->_baseAddr + _mml_heap._toSp->_szB);

}

//! forward the object that a pointer refers to from from-space to to-space.
//
static MML_word_t forward_ptr (MML_word_t r)
{
    assert (((uint64_t)r & TAG_MASK) == 0);  // pointers should be 8-byte aligned!

    if ((_mml_heap._fromSp->_baseAddr <= (uint64_t)r)
    &&  ((uint64_t)r < _mml_heap._fromSp->_usedTop)) {
      /* set p to point to the object header */
        uint64_t *p = (uint64_t *)r - 1;
      /* fetch the header word */
        uint64_t hdr = p[0];
        if ((hdr & TAG_MASK) == TAG_FWDPTR) {
          // object has already been forwarded, so return the forward pointer
            return (MML_word_t)(hdr & ~TAG_MASK);
        }
        else {
          // number of words in object (including the header word)
            int nw = MML_get_size_from_header(hdr) + 1;
            if ((hdr & TAG_MASK) == TAG_TUPLE) {
              // allocate new object in to-space
                uint64_t *newObj = (uint64_t *)_mml_heap._toSp->_usedTop;
              // copy object to to-space
                memcpy (newObj, p, sizeof(uint64_t) * nw);
                _mml_heap._toSp->_usedTop = (uint64_t)(newObj + nw);
              // bump pointer to point to start of new object
                newObj++;
              // write forward pointer into from-space object
                p[0] = (uint64_t)newObj | TAG_FWDPTR;
                return (MML_word_t)newObj;
            }
            else if ((hdr & TAG_MASK) == TAG_STRING) {
              // allocate new string in to-space
                uint64_t *newStr = (uint64_t *)_mml_heap._toSp->_usedTop;
              // copy string data and object header
                memcpy (newStr, p, sizeof(uint64_t) * nw);
                _mml_heap._toSp->_usedTop = (uint64_t)(newStr + nw);
              // bump pointer to point to start of new object
                newStr++;
              // write forward pointer into from-space object
                p[0] = (uint64_t)newStr | TAG_FWDPTR;
                return (MML_word_t)newStr;
            }
            else {
                fprintf(stderr, "***** invalid header %p at %p\n", (char *)hdr, p);
                exit (1);
            }
        }
    }
    else {
        return r;  // not a from-space pointer, so don't do anything
    }
}

//! number of bytes in a semispace
#ifdef GC_DEBUG
#  define SEMISPACE_SZB           2048
#else
#  define SEMISPACE_SZB           64*1024*1024
#endif

//! initialize the heap data structures
//
void _mml_init_heap ()
{
  /* initialize stack info table */
    StatePoints = generate_table ((void*)&STACK_MAPS, 0.5);
  /* if debugging, uncomment below */
  // print_table(stdout, StatePoints, true);

  // allocate to/from-space descriptors
    _mml_heap._toSp = (MML_semispace_t *)malloc(sizeof(MML_semispace_t));
    _mml_heap._fromSp = (MML_semispace_t *)malloc(sizeof(MML_semispace_t));

    _mml_heap._toSp->_baseAddr = (uint64_t)malloc(SEMISPACE_SZB);
    if (_mml_heap._toSp->_baseAddr == 0) {
        fprintf (stderr, "unable to allocate to-space\n");
        exit (1);
    }
    _mml_heap._toSp->_szB = SEMISPACE_SZB;
    _mml_heap._toSp->_usedTop = _mml_heap._toSp->_baseAddr;

    _mml_heap._fromSp->_baseAddr = (uint64_t)malloc(SEMISPACE_SZB);
    if (_mml_heap._fromSp->_baseAddr == 0) {
        fprintf (stderr, "unable to allocate from-space\n");
        exit (1);
    }
    _mml_heap._fromSp->_usedTop = _mml_heap._fromSp->_baseAddr;
    _mml_heap._fromSp->_szB = SEMISPACE_SZB;

  // initialize the allocation and limit pointers
    _mml_heap._allocPtr = (MML_word_t *)_mml_heap._toSp->_baseAddr;
    _mml_heap._limitPtr =
        (MML_word_t *)(_mml_heap._toSp->_baseAddr + _mml_heap._toSp->_szB);

}
